package edu.washington.escience.myria.parallel;

import edu.washington.escience.myria.DbException;
import edu.washington.escience.myria.TupleBatch;
import edu.washington.escience.myria.TupleBatchBuffer;
import edu.washington.escience.myria.operator.Operator;

/**
 * The producer part of the Collect Exchange operator.
 * 
 * The producer actively pushes the tuples generated by the child operator to the paired CollectConsumer.
 * 
 */
public class CollectProducer extends Producer {

  /** Required for Java serialization. */
  private static final long serialVersionUID = 1L;

  /**
   * @param child the child who provides data for this producer to distribute.
   * @param operatorID destination operator the data goes
   * @param collectConsumerWorkerID destination worker the data goes.
   * */
  public CollectProducer(final Operator child, final ExchangePairID operatorID, final int collectConsumerWorkerID) {
    super(child, operatorID, collectConsumerWorkerID);
  }

  @Override
  protected void consumeTuples(final TupleBatch tb) throws DbException {
    TupleBatchBuffer buffer = getBuffers()[0];

    /* You can customize the first definition of needToCompact however you like. */
    boolean needToCompact = (tb.numTuples() < TupleBatch.BATCH_SIZE);
    if (!needToCompact) {
      needToCompact = !buffer.appendTBOnlyIfFinished(tb);
    }
    if (needToCompact) {
      tb.compactInto(buffer);
    }
    popTBsFromBuffersAndWrite(true);
  }

  @Override
  protected void childEOS() throws DbException {
    popTBsFromBuffersAndWrite(false);
    super.channelEnds(0);
  }

  @Override
  protected void childEOI() throws DbException {
    getBuffers()[0].appendTB(TupleBatch.eoiTupleBatch(getSchema()));
    popTBsFromBuffersAndWrite(false);
  }
}
