package edu.washington.escience.myriad.parallel;

import java.net.InetSocketAddress;
// import java.util.ArrayList;
//
// import org.apache.mina.core.future.IoFutureListener;
// import org.apache.mina.core.future.WriteFuture;
import org.apache.mina.core.future.IoFutureListener;
import org.apache.mina.core.future.WriteFuture;
import org.apache.mina.core.session.IoSession;

// import edu.washington.escience.ConcurrentInMemoryTupleBatch;
// import edu.washington.escience.ImmutableInMemoryTupleBatch;
import edu.washington.escience.myriad.Schema;
// import edu.washington.escience.table.DbIterateReader;
import edu.washington.escience.myriad.table._TupleBatch;

/**
 * The producer part of the Collect Exchange operator.
 * 
 * The producer actively pushes the tuples generated by the child operator to the paired CollectConsumer.
 * 
 * */
public class CollectProducer extends Producer {

  private static final long serialVersionUID = 1L;

  private transient WorkingThread runningThread;

  public static final int MAX_SIZE = 100;
  public static final int MIN_SIZE = 100;
  public static final int MAX_MS = 1000;

  /**
   * The paired collect consumer address
   * */
  private final InetSocketAddress collectConsumerAddr;
  private Operator child;

  public String getName() {
    return "collect_p";
  }

  public CollectProducer(Operator child, ExchangePairID operatorID, InetSocketAddress collectServerAddr) {
    super(operatorID);
    this.child = child;
    this.collectConsumerAddr = collectServerAddr;
  }

  public InetSocketAddress getCollectServerAddr() {
    return this.collectConsumerAddr;
  }

  /**
   * The working thread, which executes the child operator and send the tuples to the paired CollectConsumer operator
   * */
  class WorkingThread extends Thread {
    public void run() {

      IoSession session =
          ParallelUtility.createSession(CollectProducer.this.collectConsumerAddr,
              CollectProducer.this.getThisWorker().minaHandler, -1);

      try {
        // ConcurrentInMemoryTupleBatch buffer = new
        // ConcurrentInMemoryTupleBatch(CollectProducer.this.getSchema());
        // long lastTime = System.currentTimeMillis();

        while (CollectProducer.this.child.hasNext()) {
          _TupleBatch tup = CollectProducer.this.child.next();
          // buffer.append(tup);
          // int cnt = buffer.numOutputTuples();
          // if (cnt >= MAX_SIZE) {
          ExchangeTupleBatch toSend =
              new ExchangeTupleBatch(CollectProducer.this.operatorID, CollectProducer.this.getThisWorker().workerID,
                  tup.outputRawData(), CollectProducer.this.getSchema(), tup.numOutputTuples());
          session.write(toSend);
          // lastTime = System.currentTimeMillis();
        }

        session.write(
            new ExchangeTupleBatch(CollectProducer.this.operatorID, CollectProducer.this.getThisWorker().workerID))
            .addListener(new IoFutureListener<WriteFuture>() {

              @Override
              public void operationComplete(WriteFuture future) {
                ParallelUtility.closeSession(future.getSession());
              }
            });// .awaitUninterruptibly(); //wait until all the data have successfully transfered
      } catch (DbException e) {
        e.printStackTrace();
      }
      // }
    }
  }

  @Override
  public void open() throws DbException {
    this.child.open();
    this.runningThread = new WorkingThread();
    this.runningThread.start();
    super.open();
  }

  public void close() {
    super.close();
    child.close();
  }

  // @Override
  // public void rewind() throws DbException {
  // throw new UnsupportedOperationException();
  // }

  @Override
  public Schema getSchema() {
    return this.child.getSchema();
  }

  @Override
  protected _TupleBatch fetchNext() throws DbException {
    try {
      // wait until the working thread terminate and return an empty tuple set
      runningThread.join();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return null;
  }

  @Override
  public Operator[] getChildren() {
    return new Operator[] { this.child };
  }

  @Override
  public void setChildren(Operator[] children) {
    this.child = children[0];
  }

}
